<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FreeRTOS STM32 实现LED闪烁，KEY任务挂起与恢复任务</title>
    <link href="/2021/01/04/stm32-freertos-key-led/"/>
    <url>/2021/01/04/stm32-freertos-key-led/</url>
    
    <content type="html"><![CDATA[<p>这两天跟着<code>哔哩哔哩</code>学习了下 <code>FreeRTOS</code>，这里把学习中实现的一个入门代码分享出来。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>这里实现的功能是，共有连个任务，一个 <code>LED</code> 闪烁任务、一个<code>KEY</code>按键任务，通过判断按键是否按下来执行<code>挂起任务</code>和<code>恢复任务</code>。</p><ul><li>按键按下<ul><li>挂起LED任务 vTaskSuspend(defaultTaskHandle);</li></ul></li><li>按键松开<ul><li>恢复LED任务 vTaskResume(defaultTaskHandle);</li></ul></li></ul><h2 id="STM32CubeMX-配置"><a href="#STM32CubeMX-配置" class="headerlink" title="STM32CubeMX 配置"></a>STM32CubeMX 配置</h2><p>我的开发板型号是 NUCLEO-F410RB 开发板，</p><p>gpio 配置图<br><img src="/img/GPIO_Config.png" alt="gpio配置图"><br><code>GPIO</code>配置分为<code>LED</code>的io配置和<code>KEY</code>的io配置，key配置为外部中断<code>上下沿</code>触发模式，<code>LED</code>的io配置为默认的输出模式。</p><p>key按键配置<br><img src="/img/key-config.png" alt="key按键配置"></p><p>sys 配置<br><img src="/img/sys-config.png" alt="sys配置"><br>SYS配置把<code>Timebase Source</code>配置为TIM6基本定时器，其他不变。</p><p>FreeRTOS配置<br><img src="/img/freeRTOS-config.png" alt="FreeRTOS配置"><br><code>FreeRTOS</code> 配置主要就是添加 <code>KEY</code>任务，把任务名和任务函数入口名修改下即可，其他默认不变。</p><p>clock配置<br><img src="/img/clock-config.png" alt="clock配置"><br>时钟配置选择外部的8M晶振，<code>HCLK</code>选择最高 <code>100MHz</code>，其他默认不变。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><h3 id="freertos-c"><a href="#freertos-c" class="headerlink" title="freertos.c"></a>freertos.c</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN Header */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  ******************************************************************************</span><br><span class="hljs-comment">  * File Name          : freertos.c</span><br><span class="hljs-comment">  * Description        : Code for freertos applications</span><br><span class="hljs-comment">  ******************************************************************************</span><br><span class="hljs-comment">  * @attention</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2021 STMicroelectronics.</span><br><span class="hljs-comment">  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * This software component is licensed by ST under Ultimate Liberty license</span><br><span class="hljs-comment">  * SLA0044, the &quot;License&quot;; You may not use this file except in compliance with</span><br><span class="hljs-comment">  * the License. You may obtain a copy of the License at:</span><br><span class="hljs-comment">  *                             www.st.com/SLA0044</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  ******************************************************************************</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/* USER CODE END Header */</span><br><br><span class="hljs-comment">/* Includes ------------------------------------------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FreeRTOS.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;task.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cmsis_os.h&quot;</span></span><br><br><span class="hljs-comment">/* Private includes ----------------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN Includes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gpio.h&quot;</span></span><br><span class="hljs-comment">/* USER CODE END Includes */</span><br><br><span class="hljs-comment">/* Private typedef -----------------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN PTD */</span><br><br><span class="hljs-comment">/* USER CODE END PTD */</span><br><br><span class="hljs-comment">/* Private define ------------------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN PD */</span><br><br><span class="hljs-comment">/* USER CODE END PD */</span><br><br><span class="hljs-comment">/* Private macro -------------------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN PM */</span><br><br><span class="hljs-comment">/* USER CODE END PM */</span><br><br><span class="hljs-comment">/* Private variables ---------------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN Variables */</span><br><span class="hljs-keyword">extern</span> UART_HandleTypeDef huart2;<br><span class="hljs-keyword">extern</span> KEY_Status KEYStatus;<br><span class="hljs-comment">/* USER CODE END Variables */</span><br>osThreadId defaultTaskHandle;<br>osThreadId SerialTaskHandle;<br>osThreadId keyTaskHandle;<br><br><span class="hljs-comment">/* Private function prototypes -----------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN FunctionPrototypes */</span><br><br><span class="hljs-comment">/* USER CODE END FunctionPrototypes */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartDefaultTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartSerialTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartTaskKEY</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MX_FREERTOS_Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">/* (MISRA C 2004 rule 8.1) */</span><br><br><span class="hljs-comment">/* GetIdleTaskMemory prototype (linked to static allocation support) */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vApplicationGetIdleTaskMemory</span><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, <span class="hljs-keyword">uint32_t</span> *pulIdleTaskStackSize )</span></span>;<br><br><span class="hljs-comment">/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */</span><br><span class="hljs-keyword">static</span> StaticTask_t xIdleTaskTCBBuffer;<br><span class="hljs-keyword">static</span> StackType_t xIdleStack[configMINIMAL_STACK_SIZE];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vApplicationGetIdleTaskMemory</span><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, <span class="hljs-keyword">uint32_t</span> *pulIdleTaskStackSize )</span></span><br><span class="hljs-function"></span>&#123;<br>  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCBBuffer;<br>  *ppxIdleTaskStackBuffer = &amp;xIdleStack[<span class="hljs-number">0</span>];<br>  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<br>  <span class="hljs-comment">/* place for user code */</span><br>&#125;<br><span class="hljs-comment">/* USER CODE END GET_IDLE_TASK_MEMORY */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  FreeRTOS initialization</span><br><span class="hljs-comment">  * @param  None</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MX_FREERTOS_Init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN Init */</span><br><br>  <span class="hljs-comment">/* USER CODE END Init */</span><br><br>  <span class="hljs-comment">/* USER CODE BEGIN RTOS_MUTEX */</span><br>  <span class="hljs-comment">/* add mutexes, ... */</span><br>  <span class="hljs-comment">/* USER CODE END RTOS_MUTEX */</span><br><br>  <span class="hljs-comment">/* USER CODE BEGIN RTOS_SEMAPHORES */</span><br>  <span class="hljs-comment">/* add semaphores, ... */</span><br>  <span class="hljs-comment">/* USER CODE END RTOS_SEMAPHORES */</span><br><br>  <span class="hljs-comment">/* USER CODE BEGIN RTOS_TIMERS */</span><br>  <span class="hljs-comment">/* start timers, add new ones, ... */</span><br>  <span class="hljs-comment">/* USER CODE END RTOS_TIMERS */</span><br><br>  <span class="hljs-comment">/* USER CODE BEGIN RTOS_QUEUES */</span><br>  <span class="hljs-comment">/* add queues, ... */</span><br>  <span class="hljs-comment">/* USER CODE END RTOS_QUEUES */</span><br><br>  <span class="hljs-comment">/* Create the thread(s) */</span><br>  <span class="hljs-comment">/* definition and creation of defaultTask */</span><br>  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>  defaultTaskHandle = osThreadCreate(osThread(defaultTask), <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* definition and creation of SerialTask */</span><br>  osThreadDef(SerialTask, StartSerialTask, osPriorityIdle, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>  SerialTaskHandle = osThreadCreate(osThread(SerialTask), <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* definition and creation of keyTask */</span><br>  osThreadDef(keyTask, StartTaskKEY, osPriorityIdle, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>  keyTaskHandle = osThreadCreate(osThread(keyTask), <span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-comment">/* USER CODE BEGIN RTOS_THREADS */</span><br>  <span class="hljs-comment">/* add threads, ... */</span><br>  <span class="hljs-comment">/* USER CODE END RTOS_THREADS */</span><br><br>&#125;<br><br><span class="hljs-comment">/* USER CODE BEGIN Header_StartDefaultTask */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  Function implementing the defaultTask thread.</span><br><span class="hljs-comment">  * @param  argument: Not used</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/* USER CODE END Header_StartDefaultTask */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartDefaultTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN StartDefaultTask */</span><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-keyword">for</span>(;;)<br>  &#123;<br>    HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);<br>    osDelay(<span class="hljs-number">1000</span>);<br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END StartDefaultTask */</span><br>&#125;<br><br><span class="hljs-comment">/* USER CODE BEGIN Header_StartSerialTask */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @brief Function implementing the SerialTask thread.</span><br><span class="hljs-comment">* @param argument: Not used</span><br><span class="hljs-comment">* @retval None</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/* USER CODE END Header_StartSerialTask */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartSerialTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN StartSerialTask */</span><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-keyword">uint8_t</span> hello[] = <span class="hljs-string">&quot;hello,stm32\n&quot;</span>;<br>  <span class="hljs-keyword">for</span>(;;)<br>  &#123;<br>    HAL_UART_Transmit(&amp;huart2, hello, <span class="hljs-keyword">sizeof</span>(hello), <span class="hljs-number">100</span>);<br>    osDelay(<span class="hljs-number">1000</span>);<br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END StartSerialTask */</span><br>&#125;<br><br><span class="hljs-comment">/* USER CODE BEGIN Header_StartTaskKEY */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @brief Function implementing the keyTask thread.</span><br><span class="hljs-comment">* @param argument: Not used</span><br><span class="hljs-comment">* @retval None</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/* USER CODE END Header_StartTaskKEY */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartTaskKEY</span><span class="hljs-params">(<span class="hljs-keyword">void</span> <span class="hljs-keyword">const</span> * argument)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN StartTaskKEY */</span><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-keyword">for</span>(;;)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (KEYStatus == KEY_DOWN) &#123;<br>      vTaskSuspend(defaultTaskHandle);  <span class="hljs-comment">// 挂起 led 任务</span><br>      KEYStatus = KEY_UNDEFINED;    <span class="hljs-comment">// 按键状态置位为 未知状态</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEYStatus == KEY_UP) &#123;<br>      vTaskResume(defaultTaskHandle);   <span class="hljs-comment">// 恢复 led 任务</span><br>      KEYStatus = KEY_UNDEFINED;    <span class="hljs-comment">// 按键状态置位为 未知状态</span><br>    &#125;<br>    osDelay(<span class="hljs-number">10</span>);<br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END StartTaskKEY */</span><br>&#125;<br><br><span class="hljs-comment">/* Private application code --------------------------------------------------*/</span><br><span class="hljs-comment">/* USER CODE BEGIN Application */</span><br><br><span class="hljs-comment">/* USER CODE END Application */</span><br><br><span class="hljs-comment">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span><br><br></code></pre></div></td></tr></table></figure><h3 id="gpio-h"><a href="#gpio-h" class="headerlink" title="gpio.h"></a>gpio.h</h3><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">/* <span class="hljs-keyword">USER</span> <span class="hljs-title">CODE</span> BEGIN Private defines */<br>typedef enum &#123;<br>  KEY_DOWN,<br>  KEY_UP,<br>  KEY_UNDEFINED<br>&#125; KEY_Status;<br>/* <span class="hljs-keyword">USER</span> <span class="hljs-title">CODE</span> END Private defines */<br></code></pre></div></td></tr></table></figure><h3 id="gpio-c"><a href="#gpio-c" class="headerlink" title="gpio.c"></a>gpio.c</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><br>KEY_Status KEYStatus = KEY_UNDEFINED;<br><span class="hljs-comment">/* USER CODE END 0 */</span><br><br><span class="hljs-comment">// 外部中断回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> GPIO_Pin)</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (GPIO_Pin == KEY_Pin) &#123;<br>    <span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(KEY_GPIO_Port, KEY_Pin) == GPIO_PIN_RESET) &#123;<br>      <span class="hljs-comment">// KEY 低电平下降沿触发</span><br>      KEYStatus = KEY_DOWN;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HAL_GPIO_ReadPin(KEY_GPIO_Port, KEY_Pin) == GPIO_PIN_SET) &#123;<br>      <span class="hljs-comment">// KEY 高电平上升沿触发</span><br>      KEYStatus = KEY_UP;<br><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2>]]></content>
    
    
    <categories>
      
      <category>电子技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>w25qxx Flash使用笔记</title>
    <link href="/2020/12/31/w251xx/"/>
    <url>/2020/12/31/w251xx/</url>
    
    <content type="html"><![CDATA[<p><code>w25qxx</code> 是一系列 <code>SPI Flash</code> 存储芯片的总称，这些芯片包括很多型号如：<code>w25q16</code> <code>w25q32</code> <code>w25q64</code>等。</p><p><code>W25Q64</code> 的擦写周期多达 <code>10W</code> 次，具有 20 年的数据保存期限，支持电压为 <code>2.7~3.6V</code>。</p><h2 id="w25q64"><a href="#w25q64" class="headerlink" title="w25q64"></a>w25q64</h2><p>W25Q64BV（64兆位）串行FLASH存储器为一个空间大小，引脚，功耗限制的系统提供解决方案。25Q系列的灵活性和性能良好超越了普通的串行FLASH设备。该芯片是理想的代码跟踪到RAM，通过两路或四路SPI（XIP）直接执行代码来存储声音，文字，数据等，只需要一个2.7V到3.6V的供电，在活跃状态是电流消耗可以低至4mA,掉电模式下可以低到1uA。所有的设备都提供节省面积的封装。</p><h2 id="w25q64-编程"><a href="#w25q64-编程" class="headerlink" title="w25q64 编程"></a>w25q64 编程</h2><h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><ul><li>w25qxx_Init(void) 初始化</li><li>w25qxx_EraseChip(void) 擦除整个芯片</li><li>w25qxx_EraseSector(uint32_t SectorAddr) 擦除单个扇区</li><li>w25qxx_EraseBlock(uint32_t BlockAddr) 擦除单个块</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>电子技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w5qxx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器类型介绍</title>
    <link href="/2020/12/30/memorizer-type/"/>
    <url>/2020/12/30/memorizer-type/</url>
    
    <content type="html"><![CDATA[<p>在学习单片机的时候，老是忘记各种存储器<code>RAM</code>,<code>ROM</code>,<code>FLASH</code>等等类型的一些区别，这里做个笔记来记录一些常用的存储器类型。</p><p>存储器按是否易失分为：易失型和非易失型</p><h2 id="易失型-RAM"><a href="#易失型-RAM" class="headerlink" title="易失型 RAM"></a>易失型 RAM</h2><ul><li>DRAM<ul><li>SDRAM</li><li>DDR SDRAM</li><li>DDRII SDRAM</li><li>DDRIII SDRAM</li></ul></li><li>SRAM</li></ul><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>动态随机存取存储器（<code>Dynamic Random Access Memory，DRAM</code>）是一种半导体存储器，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特（<code>bit</code>）是<code>1</code>还是<code>0</code>。由于在现实中晶体管会有漏电电流的现象，导致电容上所存储的电荷数量并不足以正确的判别数据，而导致数据毁损。因此对于<code>DRAM</code>来说，周期性地充电是一个无可避免的要件。由于这种需要定时刷新的特性，因此被称为“动态”存储器。相对来说，静态存储器（<code>SRAM</code>）只要存入数据后，纵使不刷新也不会丢失记忆</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>静态随机存取存储器（<code>Static Random-Access Memory，SRAM</code>）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（<code>DRAM</code>）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，<code>SRAM</code>储存的数据还是会消失（被称为<code>volatile memory</code>），这与在断电后还能储存资料的<code>ROM</code>或闪存是不同的。</p><h3 id="SDRAM"><a href="#SDRAM" class="headerlink" title="SDRAM"></a>SDRAM</h3><p>同步动态随机存取内存（<code>synchronous dynamic random-access memory</code>，简称<code>SDRAM</code>）是有一个同步接口的动态随机存取内存（<code>DRAM</code>）。通常<code>DRAM</code>是有一个异步接口的，这样它可以随时响应控制输入的变化。而<code>SDRAM</code>有一个同步接口，在响应控制输入前会等待一个时钟信号，这样就能和计算机的系统总线同步。时钟被用来驱动一个有限状态机，对进入的指令进行管线(<code>Pipeline</code>)操作。这使得<code>SDRAM</code>与没有同步接口的异步<code>DRAM</code>(<code>asynchronous DRAM</code>)相比，可以有一个更复杂的操作模式。</p><h2 id="非易失型-ROM"><a href="#非易失型-ROM" class="headerlink" title="非易失型 ROM"></a>非易失型 ROM</h2><ul><li>ROM<ul><li>MASK ROM</li><li>PROM<ul><li>OTPROM</li><li>EPROM</li><li>EEPROM</li></ul></li></ul></li><li>FLASH<ul><li>NOR FLASH</li><li>NAND FLASH</li></ul></li></ul><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>只读存储器（Read-Only Memory，ROM）以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。ROM所存数据通常是装入整机前写入的，整机工作过程中只能读出，不像随机存储器能快速方便地改写存储内容。ROM所存数据稳定 ，断电后所存数据也不会改变，并且结构较简单，使用方便，因而常用于存储各种固定程序和数据。</p><h3 id="MASK-ROM"><a href="#MASK-ROM" class="headerlink" title="MASK ROM"></a>MASK ROM</h3><p>掩膜只读存储器（<code>Mask ROM</code>）中存储的信息由生产厂家在掩膜工艺过程中“写入”。在制造过程中，将资料以一特制光罩（<code>Mask</code>）烧录于线路中，有时又称为“光罩式只读内存”（<code>Mask ROM</code>），此内存的制造成本较低，常用于电脑中的开机启动。其行线和列线的交点处都设置了MOS管，在制造时的最后一道掩膜工艺，按照规定的编码布局来控制<code>MOS</code>管是否与行线、列线相连。相连者定为1（或0），未连者为0（或1），这种存储器一旦由生产厂家制造完毕，用户就无法修改。</p><p><code>MROM</code>的主要优点是存储内容固定，掉电后信息仍然存在,可靠性高。缺点是信息一次写入（制造）后就不能修改，很不灵活且生产周期长，用户与生产厂家之间的依赖性大。</p><h3 id="PROM-可编程只读存储器"><a href="#PROM-可编程只读存储器" class="headerlink" title="PROM - 可编程只读存储器"></a>PROM - 可编程只读存储器</h3><p>可编程只读存储器（<code>Programmable ROM，PROM</code>）允许用户通过专用的设备（编程器）一次性写入自己所需要的信息，其一般可编程一次，<code>PROM</code>存储器出厂时各个存储单元皆为1，或皆为0。用户使用时，再使用编程的方法使<code>PROM</code>存储所需要的数据。</p><p><code>PROM</code>的种类很多，需要用电和光照的方法来编写与存放的程序和信息。但仅仅只能编写一次，第一次写入的信息就被永久性地保存起来。例如，双极性<code>PROM</code>有两种结构：一种是熔丝烧断型，一种是<code>PN</code>结击穿型。它们只能进行一次性改写，一旦编程完毕，其内容便是永久性的。由于可靠性差，又是一次性编程，较少使用。<code>PROM</code>中的程序和数据是由用户利用专用设备自行写入，一经写入无法更改，永久保存。<code>PROM</code>具有一定的灵活性，适合小批量生产，常用于工业控制机或电器中。</p><h3 id="OTPROM-一次编程只读内存"><a href="#OTPROM-一次编程只读内存" class="headerlink" title="OTPROM - 一次编程只读内存"></a>OTPROM - 一次编程只读内存</h3><p>一次编程只读内存（<code>One Time Programmable Read Only Memory，OTPROM</code>）之写入原理同<code>EPROM</code>，但是为了节省成本，编程写入之后就不再抹除，因此不设置透明窗。</p><h3 id="EPROM-可编程可擦除只读存储器"><a href="#EPROM-可编程可擦除只读存储器" class="headerlink" title="EPROM - 可编程可擦除只读存储器"></a>EPROM - 可编程可擦除只读存储器</h3><p>可编程可擦除只读存储器（<code>Erasable Programmable Read Only Memory，EPROM</code>）可多次编程，是一种以读为主的可写可读的存储器。是一种便于用户根据需要来写入，并能把已写入的内容擦去后再改写的<code>ROM</code>。其存储的信息可以由用户自行加电编写，也可以利用紫外线光源或脉冲电流等方法先将原存的信息擦除，然后用写入器重新写入新的信息。 <code>EPROM</code>比<code>MROM</code>和<code>PROM</code>更方便、灵活、经济实惠。但是<code>EPROM</code>采用<code>MOS</code>管，速度较慢。</p><h3 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h3><p>电可擦可编程序只读存储器（<code>Electrically Erasable Programmable Read-Only Memory，EEPROM</code>）是一种随时可写入而无须擦除原先内容的存储器，其写操作比读操作时间要长得多，<code>EEPROM</code>把不易丢失数据和修改灵活的优点组合起来，修改时只需使用普通的控制、地址和数据总线。<code>EEPROM</code>运作原理类似<code>EPROM</code>，但抹除的方式是使用高电场来完成，因此不需要透明窗。 <code>EEPROM</code>比 <code>EPROM</code>贵，集成度低，成本较高，一般用于保存系统设置的参数、<code>IC</code>卡上存储信息、电视机或空调中的控制器。但由于其可以在线修改，所以可靠性不如 <code>EPROM</code>。</p><h3 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h3><p>快擦除读写存储器(<code>Flash Memory</code>)是英特尔公司90年代中期发明的一种高密度、非易失性的读/写半导体存储器它既有<code>EEPROM</code>的特点，又有<code>RAM</code>的特点，是一种全新的存储结构，俗称快闪存储器。它在20世纪80年代中后期首次推出，快闪存储器的价格和功能介于 <code>EPROM</code>和<code>EEPROM</code>之间。与 <code>EEPROM</code>一样，快闪存储器使用电可擦技术，整个快闪存储器可以在一秒钟至几秒内被擦除，速度比 <code>EPROM</code>快得多。另外，它能擦除存储器中的某些块，而不是整块芯片。然而快闪存储器不提供字节级的擦除，与 <code>EPROM</code>一样，快闪存储器每位只使用一个晶体管，因此能获得与 <code>EPROM</code>一样的高密度(与 <code>EEPROM</code>相比较)。“闪存”芯片采用单一电源（3V或者5V）供电，擦除和编程所需的特殊电压由芯片内部产生，因此可以在线系统擦除与编程。“闪存”也是典型的非易失性存储器，在正常使用情况下，其浮置栅中所存电子可保存100年而不丢失。</p><h3 id="NOR-FLASH-于-NAND-FLASH"><a href="#NOR-FLASH-于-NAND-FLASH" class="headerlink" title="NOR FLASH 于 NAND FLASH"></a>NOR FLASH 于 NAND FLASH</h3><p>是市场上两种主要的非易失闪存技术之一。<code>Intel</code>于1988年首先开发出<code>NOR Flash</code> 技术，彻底改变了原先由<code>EPROM</code>(<code>Erasable Programmable Read-Only-Memory</code>电可编程序只读存储器)和<code>EEPROM</code>(电可擦只读存储器<code>Electrically Erasable Programmable Read - Only Memory</code>)一统天下的局面。紧接着，1989年，东芝公司发表了<code>NAND Flash</code> 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。<code>NOR Flash</code> 的特点是芯片内执行（<code>XIP ，eXecute In Place</code>），这样应用程序可以直接在<code>Flash</code>闪存内运行，不必再把代码读到系统<code>RAM</code>中。<code>NOR</code> 的传输效率很高，在1~4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响到它的性能。<code>NAND</code>的结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用<code>NAND</code>的困难在于<code>Flash</code>的管理需要特殊的系统接口。通常读取<code>NOR</code>的速度比<code>NAND</code>稍快一些，而<code>NAND</code>的写入速度比<code>NOR</code>快很多，在设计中应该考虑这些情况。</p><p>关于更详细的 <code>NOR FLASH</code> 和 <code>NAND FLASH</code> 讲解请看下面这篇文章：<br><a href="https://www.cnblogs.com/iriczhao/p/12128451.html">https://www.cnblogs.com/iriczhao/p/12128451.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储器</tag>
      
      <tag>ROM</tag>
      
      <tag>RAM</tag>
      
      <tag>FLASH</tag>
      
      <tag>SDRAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 GPIO 寄存器</title>
    <link href="/2020/12/30/stm32-gpio/"/>
    <url>/2020/12/30/stm32-gpio/</url>
    
    <content type="html"><![CDATA[<p>本篇文章来了解下 <code>stm32</code> 的 <code>gpio</code> 寄存器，<code>STM32</code>的<code>GPIO</code>共有11个寄存器，下面来详细介绍：</p><p>每个通用 <code>I/O</code> 端口都有一下寄存器</p><ul><li>4 个 32 位配置寄存器（<code>GPIOx_MODER</code>、<code>GPIOx_OTYPER</code>、<code>GPIOx_OSPEEDR</code> 和 <code>GPIOx_PUPDR</code>）</li><li>2个32位数据寄存器(<code>GPIOx_IDR</code> 和 <code>GPIOx_ODR</code>)</li><li>1个32位置位/复位寄存器(<code>GPIOx_BSRR</code>)</li><li>1个16位复位寄存器(<code>GPIOx_BRR</code>)</li><li>1个32位锁定寄存器(<code>GPIOx_LCKR</code>)</li><li>2 个 32 位复用功能选择寄存器（<code>GPIOx_AFRH</code> 和 <code>GPIOx_AFRL</code>）</li></ul><h2 id="GPIO-主要特性"><a href="#GPIO-主要特性" class="headerlink" title="GPIO 主要特性"></a>GPIO 主要特性</h2><ul><li>受控 <code>I/O</code> 多达 16 个</li><li>输出状态：推挽或开漏 + 上拉/下拉</li><li>从输出数据寄存器 (<code>GPIOx_ODR</code>) 或外设（复用功能输出）输出数据</li><li>可为每个 <code>I/O</code> 选择不同的速度</li><li>输入状态：浮空、上拉/下拉、模拟</li><li>将数据输入到输入数据寄存器 (<code>GPIOx_IDR</code>) 或外设（复用功能输入）</li><li>置位和复位寄存器 (<code>GPIOx_BSRR</code>)，对 <code>GPIOx_ODR</code> 具有按位写权限</li><li>锁定机制 (<code>GPIOx_LCKR</code>)，可冻结 <code>I/O</code> 配置</li><li>模拟功能</li><li>复用功能输入/输出选择寄存器（一个 <code>I/O</code> 最多可具有 16 个复用功能）</li><li>快速翻转，每次翻转最快只需要两个时钟周期</li><li>引脚复用非常灵活，允许将 <code>I/O</code> 引脚用作 <code>GPIO</code> 或多种外设功能中的一种</li></ul><p>每个<code>I/O</code>端口位可以自由编程，然而必须按照32位字访问<code>I/O</code>端口寄存器(不允许半字或字节访问)。</p><p><code>GPIOx_BSRR</code>和<code>GPIOx_BRR</code>寄存器允许对任何<code>GPIO</code>寄存器进行读/更改的独立访问；这样，在读和更改访问之间产生<code>IRQ</code>时不会发生危险。</p><h2 id="GPIO-功能描述"><a href="#GPIO-功能描述" class="headerlink" title="GPIO 功能描述"></a>GPIO 功能描述</h2><p>根据数据手册中列出的每个 I/O 端口的特性，可通过软件将通用 I/O (GPIO) 端口的各个端口 位分别配置为多种模式：</p><ul><li>输入浮空</li><li>输入上拉</li><li>输入下拉</li><li>模拟功能</li><li>具有上拉或下拉功能的开漏输出</li><li>具有上拉或下拉功能的推挽输出</li><li>具有上拉或下拉功能的复用功能推挽</li><li>具有上拉或下拉功能的复用功能开漏</li></ul><p>下图给出了一个<code>I/O</code>端口位的基本结构。</p><p><img src="/img/stm32-gpio-1.png" alt="STM32 GPIO"></p><h2 id="I-O-端口控制寄存器"><a href="#I-O-端口控制寄存器" class="headerlink" title="I/O 端口控制寄存器"></a>I/O 端口控制寄存器</h2><p>每个 <code>GPIO</code> 有 4 个 32 位存储器映射的控制寄存器（<code>GPIOx_MODER</code>、<code>GPIOx_OTYPER</code>、 <code>GPIOx_OSPEEDR</code>、<code>GPIOx_PUPDR</code>），可配置多达 16 个 <code>I/O</code>。</p><ul><li><code>GPIOx_MODER</code> 寄存器用于 选择 I/O 方向（输入、输出、AF、模拟）。</li><li><code>GPIOx_OTYPER</code> 和 <code>GPIOx_OSPEEDR</code> 寄存器分 别用于选择输出类型（推挽或开漏）和速度 (无论采用哪种 I/O 方向，都会直接将 I/O 速度引 脚连接到相应的<code>GPIOx_OSPEEDR</code> 寄存器位）。无论采用哪种 <code>I/O</code> 方向，<code>GPIOx_PUPDR</code> 寄 存器都用于选择上拉/下拉。</li><li><code>GPIOx_PUPDR</code> 寄存器都用于选择上拉/下拉</li></ul><h2 id="I-O-端口数据寄存器"><a href="#I-O-端口数据寄存器" class="headerlink" title="I/O 端口数据寄存器"></a>I/O 端口数据寄存器</h2><p>每个 <code>GPIO</code> 都具有 2 个 16 位数据寄存器：输入和输出数据寄存器（<code>GPIOx_IDR</code> 和 <code>GPIOx_ODR</code>）。<code>GPIOx_ODR</code> 用于存储待输出数据，可对其进行读/写访问。通过 <code>I/O</code> 输入的数据存储到输入数据寄存器 (<code>GPIOx_IDR</code>) 中，它是一个<strong>只读寄存器</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>电子技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>GPIO</tag>
      
      <tag>IO</tag>
      
      <tag>寄存器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一款 STM32 的 vscode 插件，stm32-for-vscode</title>
    <link href="/2020/12/29/stm32-for-vscode/"/>
    <url>/2020/12/29/stm32-for-vscode/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/bmd-studio/stm32-for-vscode">stm32-for-vscode</a> 是一款用于使用 <code>vscode</code> 来开发 <code>stm32</code> 项目的插件，这款插件是 2019 首次发布的，属于比较新的插件了，通过测试可以使用。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>该插件可以实现快速的 <span class="label label-primary">编译</span> <span class="label label-primary">下载</span> <span class="label label-primary">调试</span> STM32 项目，先决条件是：</p><ol><li><a href="https://github.com/Marus/cortex-debug">Cortex-Debug</a>，安装这个 vscode 扩展和基础的C/C++插件</li><li><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">GNU Arm Embedded Toolchain</a>，安装该软件，并配置好环境变量</li><li><a href="http://gnuwin32.sourceforge.net/packages/make.htm">Make</a> ，电脑上要有 make.exe，并且配好环境变量</li><li><a href="https://gnutoolchains.com/arm-eabi/openocd/">OpenOCD</a>，安装 OpenOCD，并配置环境变量</li></ol><p>以上4条是先决条件，接下来使用 <code>ST</code>官方提供的 <code>STM32CubeMX</code> 来创建一个项目，在项目配置 <code>Toolchain / IDE</code> 处选择 <code>Makefile</code>。</p><p>创建完成项目后，用<code>vscode</code>打开，执行 <code>ctrl+shift+p</code> 打开命令面板，在面板中输入 “stm32”后会出现三个命令，分别为：<br><img src="/img/stm32-for-vscode.png" alt="stm32 for vscode"></p><p>第一次执行编译命令后，会在项目中生成 <code>.vscode</code> 文件夹，文件夹中包含一下几个文件:</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">c_cpp_properties</span><span class="hljs-selector-class">.json</span><br><span class="hljs-selector-tag">launch</span><span class="hljs-selector-class">.json</span><br><span class="hljs-selector-tag">settings</span><span class="hljs-selector-class">.json</span><br><span class="hljs-selector-tag">tasks</span><span class="hljs-selector-class">.json</span><br></code></pre></div></td></tr></table></figure><p>这几个文件就是 <code>stm32-for-vscode</code> 这几个插件生成的，默认也是配置好的，可以不用修改直接使用。</p><h2 id="给任务添加快捷键"><a href="#给任务添加快捷键" class="headerlink" title="给任务添加快捷键"></a>给任务添加快捷键</h2><p><code>ctrl+1</code> : 编译<br><code>ctrl+2</code> : 下载<br><code>ctrl+3</code> : Clean 与 编译</p><p>keybindings.json</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">[<br>    &#123;<br>        <span class="hljs-attr">&quot;key&quot;</span>: <span class="hljs-string">&quot;ctrl+1&quot;</span>,<br>        <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;workbench.action.tasks.runTask&quot;</span>,<br>        <span class="hljs-attr">&quot;args&quot;</span>: <span class="hljs-string">&quot;Build STM&quot;</span>,<br>        <span class="hljs-attr">&quot;when&quot;</span>: <span class="hljs-string">&quot;editorTextFocus&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;key&quot;</span>: <span class="hljs-string">&quot;ctrl+2&quot;</span>,<br>        <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;workbench.action.tasks.runTask&quot;</span>,<br>        <span class="hljs-attr">&quot;args&quot;</span>: <span class="hljs-string">&quot;Flash STM&quot;</span>,<br>        <span class="hljs-attr">&quot;when&quot;</span>: <span class="hljs-string">&quot;editorTextFocus&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;key&quot;</span>: <span class="hljs-string">&quot;ctrl+3&quot;</span>,<br>        <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;workbench.action.tasks.runTask&quot;</span>,<br>        <span class="hljs-attr">&quot;args&quot;</span>: <span class="hljs-string">&quot;Build Clean STM&quot;</span>,<br>        <span class="hljs-attr">&quot;when&quot;</span>: <span class="hljs-string">&quot;editorTextFocus&quot;</span><br>    &#125;<br>]<br></code></pre></div></td></tr></table></figure><ul><li><strong>key</strong> 表示绑定的键。</li><li><strong>command</strong> 表示执行的命令。</li><li><strong>args</strong> 命令的参数，这里我们是build编译任务</li><li><strong>when</strong> 快捷键在何时生效，这里指的是编辑区</li></ul>]]></content>
    
    
    <categories>
      
      <category>电子技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>vscode</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSYS2 命令笔记</title>
    <link href="/2020/12/29/msys2-command/"/>
    <url>/2020/12/29/msys2-command/</url>
    
    <content type="html"><![CDATA[<p>首先说说什么是 <code>MSYS2</code> ？</p><p><code>MSYS2 （Minimal SYStem 2)</code> 是一个<code>MSYS</code>的独立改写版本，主要用于 <code>shell</code> 命令行开发环境。同时它也是一个在<code>Cygwin</code> （<code>POSIX</code> 兼容性层） 和 <code>MinGW-w64</code>（从”<code>MinGW</code>-生成”）基础上产生的，追求更好的互操作性的 <code>Windows</code> 软件。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pacman -Sy 更新软件包数据<br>pacman -R package-name 删除软件包<br>pacman -S package-name 安装软件包<br>pacman -Syu 更新所有<br>pacman -Ss xx 查询软件xx的信息<br></code></pre></div></td></tr></table></figure><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>安装软件通过 <code>pacman -S package-name</code> 来安装。</p><p>如果不知道具体的软件名或要安装的版本信息，则可以先通过 <code>pacman -Ss xx 查询软件xx的信息</code>命令，来先查一下软件的具体信息；因为有些软件包含很多的版本,所以通过该命令来找到具体的软件包名称后，通过复制软件名再通过 <code>pacman -S</code> 来安装。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://www.msys2.org/">https://www.msys2.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MSYS2</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 VSCode 开发 STM32 项目</title>
    <link href="/2020/12/29/stm32-vscode-dev/"/>
    <url>/2020/12/29/stm32-vscode-dev/</url>
    
    <content type="html"><![CDATA[<p>vscode 是一款最好用的开发工具之一，该软件非常好用强大，通过安装插件几乎可以完成所有的开发工作。</p><p>用 vscode 开发 stm32 的步骤是：</p><ol><li>用<code>STM32CubeMX</code> 生成 <code>stm32</code> 项目，注意要生成 <code>Makefile</code> 项目</li><li>使用 stm32-for-vscode 插件来 <span class="label label-primary">编译</span> <span class="label label-primary">调试</span> <span class="label label-primary">下载</span> 代码。</li><li>添加自己的 <code>c</code> 源文件和头文件，并把这些文件的路径添加到 <code>Makefile</code> 中</li></ol><p>所以要维护的也就是 <code>Makefile</code> 文件。</p><h2 id="添加-u-printf-float-u-sprintf-float"><a href="#添加-u-printf-float-u-sprintf-float" class="headerlink" title="添加 -u_printf_float -u_sprintf_float"></a>添加 -u_printf_float -u_sprintf_float</h2><p>添加串口打印浮点数的功能</p><p>在 Makefile 中这行代码前添加</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile">LDFLAGS = <span class="hljs-variable">$(MCU)</span> -u_printf_float -u_sprintf_float -specs=nano.specs -T<span class="hljs-variable">$(LDSCRIPT)</span> <span class="hljs-variable">$(LIBDIR)</span> <span class="hljs-variable">$(LIBS)</span> -Wl,-Map=<span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(TARGET)</span>.map,--cref -Wl,--gc-sections<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>电子技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 配置笔记</title>
    <link href="/2020/12/28/Hexo-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/28/Hexo-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇介绍 <code>hexo</code> 配置的文章。</p><h2 id="选择一款主题"><a href="#选择一款主题" class="headerlink" title="选择一款主题"></a>选择一款主题</h2><p>在我有意的搜索中，发现了这款漂亮的主题 <code>fluid</code>，这是一款 <code>Material Design</code> 风格的主题，通过测试发现这款主题还是比较完美的。</p><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="/img/fluid.png" alt="fluid"></p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><ul><li><a href="https://hexo.fluid-dev.com/">https://hexo.fluid-dev.com/</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></li></ul><p>该主题对中文用户非常友好，配置中的注释都是中文的，所有功能开箱即用。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>快速开始使用 Hexo 写文章并且发布到 <code>Github Page</code> 上，前提是还要安装个插件：</p><p><code>$ npm install hexo-deployer-git --save</code></p><p>这里贴上配置代码：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&#x27;https://github.com/FY2008/fy2008.github.io.git&#x27;</span> <span class="hljs-comment"># https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">&#x27;main&#x27;</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;站点更新: <span class="hljs-template-variable">&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span>&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2><h3 id="init-初始化"><a href="#init-初始化" class="headerlink" title="init 初始化"></a>init 初始化</h3><p><code>$ hexo init [folder]</code></p><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new-新建命令"><a href="#new-新建命令" class="headerlink" title="new 新建命令"></a>new 新建命令</h3><p><code>$ hexo new [layout] &lt;title&gt;</code></p><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-p, –path</td><td align="left">自定义新文章的路径</td></tr><tr><td align="left">-r, –replace</td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left">-s, –slug</td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p><p><code>hexo new page --path about/me &quot;About me&quot;</code></p><p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><p><code>hexo new page --path about/me</code></p><p><code>D:\dev\blog&gt;hexo new post -p stm32-for-vscode &quot;推荐一款 STM32 的 vscode 插件，stm32-for-vscode&quot;</code></p><p>这条命令是新建一个文章，并且指定路径名和文章标题名，路径名通过 <code>-p</code> 指定，文章标题名在最后面，并且用双引号括起来，以为文章标题包含空格。</p><h3 id="generate-生成命令（g）"><a href="#generate-生成命令（g）" class="headerlink" title="generate 生成命令（g）"></a>generate 生成命令（g）</h3><p><code>$ hexo generate</code><br>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-d, –deploy</td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left">-w, –watch</td><td align="left">监视文件变动</td></tr><tr><td align="left">-b, –bail</td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left">-f, –force</td><td align="left">强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td align="left">-c, –concurrency</td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为:</p><p><code>$ hexo g</code></p><h3 id="建立文章草稿"><a href="#建立文章草稿" class="headerlink" title="建立文章草稿"></a>建立文章草稿</h3><p><code>$ hexo new draft &lt;title&gt;</code></p><p><code>Hexo</code> 另外提供 <code>draft</code> 机制，它的原理是新文章将建立在 <code>source/_drafts</code> 目录下，因此 <code>hexo generate</code> 并不会将其编译到 <code>public</code> 目录下，所以 <code>hexo deploy</code> 也不会将其部署到 <code>GitHub</code>。</p><h3 id="将草稿发布为正式文章"><a href="#将草稿发布为正式文章" class="headerlink" title="将草稿发布为正式文章"></a>将草稿发布为正式文章</h3><p><code>$ hexo publish [layout] &lt;filename&gt;</code><br><code>$ hexo P &lt;filename&gt;</code></p><p>其中 <code>&lt;filename&gt;</code> 为不包含 <code>md</code> 后缀的文章名称。它的原理只是将文章从 <code>source/_drafts</code> 移动到 <code>source/_posts</code> 而已。</p><h3 id="server-启动本地服务器"><a href="#server-启动本地服务器" class="headerlink" title="server 启动本地服务器"></a>server 启动本地服务器</h3><p><code>$ hexo server</code></p><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-p, –port</td><td align="left">重设端口</td></tr><tr><td align="left">-s, –static</td><td align="left">只使用静态文件</td></tr><tr><td align="left">-l, –log</td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><p>该命令可以简写为:</p><p><code>$ hexo s</code></p><h3 id="deploy-部署命令"><a href="#deploy-部署命令" class="headerlink" title="deploy 部署命令"></a>deploy 部署命令</h3><p><code>$ hexo deploy</code></p><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-g, –generate</td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><p><code>$ hexo d</code></p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p><code>$ hexo clean</code></p><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>$ hexo list &lt;type&gt;</code></p><p>list 命令参数</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">Argument<span class="hljs-variable">s:</span><br>  <span class="hljs-built_in">type</span>  Available <span class="hljs-built_in">type</span><span class="hljs-variable">s:</span> page, post, route, <span class="hljs-keyword">tag</span>, category<br></code></pre></div></td></tr></table></figure><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p><code>$ hexo version</code></p><p>显示 Hexo 版本。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><p><code>$ hexo --draft</code></p><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h2 id="Fluid-主题-tag-标签插件的颜色"><a href="#Fluid-主题-tag-标签插件的颜色" class="headerlink" title="Fluid 主题 tag 标签插件的颜色"></a>Fluid 主题 tag 标签插件的颜色</h2><figure class="highlight django"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> success %&#125;</span><br><span class="xml">文字 或者 `markdown` 均可</span><br><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></div></td></tr></table></figure><p>或者使用 HTML 形式：</p><p><code>&lt;p class=&quot;note note-primary&quot;&gt;标签&lt;/p&gt;</code></p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h3 id="可选便签"><a href="#可选便签" class="headerlink" title="可选便签"></a>可选便签</h3><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><div class="note note-warning">            <p><strong>WARNING</strong></p><p><code>使用时 &lt;div class=&quot;note note-primary&quot;&gt;             &lt;p&gt;和 &lt;/p&gt;           &lt;/div&gt; 需单独一行，否则会出现问题</code></p>          </div><h3 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h3><p>在 <code>markdown</code> 中加入如下的代码来使用 <code>Label</code>：</p><p><code>&#123;% label primary @text %&#125;</code></p><p>或者使用 HTML 形式：</p><p><code>&lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt;</code></p><span class="label label-primary">text</span><span class="label label-default">text</span><span class="label label-info">text</span><span class="label label-success">text</span><span class="label label-warning">text</span><span class="label label-danger">text</span><h3 id="勾选框"><a href="#勾选框" class="headerlink" title="勾选框"></a>勾选框</h3><p>在 markdown 中加入如下的代码来使用 Checkbox：<br><code>&#123;% cb text, checked?, incline? %&#125;</code></p><p>text：显示的文字<br>checked：默认是否已勾选，默认 false<br>incline: 是否内联（可以理解为后面的文字是否换行），默认 false</p>            <input type="checkbox" disabled checked="checked">text                      <input type="checkbox" disabled >text                      <input type="checkbox" disabled >text          <input type="checkbox" disabled > text<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>你可以在 markdown 中加入如下的代码来使用 Button：</p><p><code>&#123;% btn url, text, title %&#125;</code></p><p>或者使用 HTML 形式：</p><p><code>&lt;a class=&quot;btn&quot; href=&quot;url&quot; title=&quot;title&quot;&gt;text&lt;/a&gt;</code></p><a class="btn" href="https://www.github.com/fy2008"  title="Github" target="_blank">Github</a>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/28/hello-world/"/>
    <url>/2020/12/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
